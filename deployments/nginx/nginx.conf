worker_processes auto;

events {
  worker_connections 1024;
}

http {
  include /etc/nginx/mime.types;
  default_type application/octet-stream;

  access_log /var/log/nginx/access.log;
  error_log  /var/log/nginx/error.log warn;

  # 10 requests/second per IP (for /predict)
  limit_req_zone $binary_remote_addr zone=predict_rl:10m rate=10r/s;

  # v1 load-balanced (3 replicas created via: docker compose up --scale api-v1=3)
  upstream api_v1_upstream {
    least_conn;
    server api-v1:8000;
  }

  # HTTP -> HTTPS redirect
  server {
    listen 80;
    server_name localhost;
    return 301 https://$host$request_uri;
  }

  # HTTPS reverse proxy
  server {
    listen 443 ssl;
    server_name localhost;

    ssl_certificate     /etc/nginx/certs/nginx.crt;
    ssl_certificate_key /etc/nginx/certs/nginx.key;
    ssl_protocols TLSv1.2 TLSv1.3;

    # Metrics endpoint for Prometheus exporter (restricted)
    location /stub_status {
      stub_status;
      allow 127.0.0.1;
      allow ::1;
      allow 172.16.0.0/12;
      allow 192.168.0.0/16;
      deny all;
    }

    # Default route -> v1
    location / {
      proxy_set_header Host $host;
      proxy_set_header X-Real-IP $remote_addr;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_set_header X-Forwarded-Proto $scheme;

      proxy_pass http://api_v1_upstream;
    }

    # Protected + rate limited endpoint
    location /predict {
      # Basic auth
      auth_basic "Restricted";
      auth_basic_user_file /etc/nginx/.htpasswd;

      # Rate limiting
      limit_req zone=predict_rl burst=20 nodelay;

      proxy_set_header Host $host;
      proxy_set_header X-Real-IP $remote_addr;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_set_header X-Forwarded-Proto $scheme;

      # A/B routing: debug header -> v2
      if ($http_x_experiment_group = "debug") {
        proxy_pass http://api-v2:8000;
        break;
      }

      proxy_pass http://api_v1_upstream;
    }
  }
}